// Package testdata GENERATED BY enum DO NOT EDIT
package testdata

import (
	"bytes"
	"database/sql/driver"
	"fmt"

	"github.com/xoctopus/enumx/pkg/enumx"
)

var _ enumx.Enum[Status] = (*Status)(nil)

// ParseStatus parse Status from key
func ParseStatus(key string) (Status, error) {
	switch key {
	case "ENABLED":
		return STATUS__ENABLED, nil
	case "DISABLED":
		return STATUS__DISABLED, nil
	default:
		var v Status
		if _, err := fmt.Sscanf(key, "UNKNOWN_%d", &v); err != nil {
			return v, nil
		}
		return STATUS_UNKNOWN, enumx.ParseErrorFor[Status](key)
	}
}

// Values returns enum value list of Status
func (Status) Values() []Status {
	return []Status{
		STATUS__ENABLED,
		STATUS__DISABLED,
	}
}

// String returns v's string as key
func (v Status) String() string {
	switch v {
	case STATUS__ENABLED:
		return "ENABLED"
	case STATUS__DISABLED:
		return "DISABLED"
	default:
		return fmt.Sprintf("UNKNOWN_%d", v)
	}
}

// Text returns the description as for human reading
func (v Status) Text() string {
	switch v {
	case STATUS__ENABLED:
		return "关闭"
	case STATUS__DISABLED:
		return "开启"
	default:
		return v.String()
	}
}

// IsZero checks if v is zero
func (v Status) IsZero() bool {
	return v == STATUS_UNKNOWN
}

// MarshalText implements encoding.TextMarshaler
func (v Status) MarshalText() ([]byte, error) {
	return []byte(v.String()), nil
}

// UnmarshalText implements encoding.TextUnmarshaler
func (v *Status) UnmarshalText(data []byte) error {
	vv, err := ParseStatus(string(bytes.ToUpper(data)))
	if err != nil {
		return err
	}
	*v = vv
	return nil
}

// Gender describes Gender attribute
func (v Status) Gender() Gender {
	switch v {
	case STATUS__ENABLED:
		return Gender(1)
	case STATUS__DISABLED:
		return Gender(2)
	default:
		return *new(Gender)
	}
}

// Value implements driver.Valuer
func (v Status) Value() (driver.Value, error) {
	offset := 0
	if drv, ok := any(v).(enumx.DriverValueOffset); ok {
		offset = drv.Offset()
	}
	return int64(v) + int64(offset), nil
}

// Scan implements sql.Scanner
func (v *Status) Scan(src any) error {
	offset := 0
	if offsetter, ok := any(v).(enumx.DriverValueOffset); ok {
		offset = offsetter.Offset()
	}
	i, err := enumx.Scan(src, offset)
	if err != nil {
		return err
	}
	*v = Status(i)
	return nil
}
